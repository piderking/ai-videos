import os, requests
import json
import re
import requests
import random
from datetime import timedelta
from datetime import timedelta
import os

import whisper
from whisper.utils import get_writer 



def transcribe_audio(count):
    audio = './data/{}/tts.mp3'.format(count)
    model = whisper.load_model('base')
    result = model.transcribe(audio=audio, language='en', word_timestamps=True, task="transcribe")

    # Set VTT Line and words width
    word_options = {
        "highlight_words": False,
        "max_line_count": 1,
        "max_line_width": 30
    }
    vtt_writer = get_writer(output_format='srt', output_dir='./data/{}/'.format(count))
    vtt_writer(result, audio, word_options)


# Fore testing $ENV:URLS="https://www.reddit.com/r/AmItheAsshole/comments/1bzvso5/aita_for_trying_to_take_back_80k_of_the_160000_my/;https://www.reddit.com/r/AmItheAsshole/comments/1c01rms/aita_if_i_sell_my_youngest_daughters_car_to_help"
links = os.environ.get("URLS").split(";")
# ENVIRONMENT VARIABLES (TODO Make these call from Enviroment)
DURATION=60 # Seconds

print(links)
# JSON Data from Reddit
#table = requests.get("https://www.reddit.com/r/AmItheAsshole/hot.json",).json()
table = json.loads(open("hot.json", "r").read())


# Where all the titles/text will be generated to
titles = []
texts = []
video_types = ["nature", "drone videos", "sunset", "ocean"]
# HTTP Headers for 11 Labs
headers = {
  "Accept": "audio/mpeg",
  "Content-Type": "application/json",
  "xi-api-key": "c798607f1c366ac93066a74e50a10d4f"
}
CHUNK_SIZE = 2048
# Functions

# Create Directories
if not os.path.exists("data/"):
    os.mkdir("data")
if not os.path.exists("build/"):
    os.mkdir("build")


def addCustomStyles(count: int):
    f = open("data/{}/subs.ass".format(count), "r")

    # Use the Custom Styles

    temp = """[Script Info]
    ; Script generated by FFmpeg/Lavc61.3.100
    ScriptType: v4.00+
    PlayResX: 384
    PlayResY: 288
    ScaledBorderAndShadow: yes
    YCbCr Matrix: None

    [V4+ Styles]
    Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
    Style: Default,Roboto,16,&Hffffff,&Hffffff,&H0,&H0,0,0,0,0,100,100,0,0,0,1,0,2,10,10,120,1

    [Events]{}""".format(f.read().split("[Events]")[1])
    
    vals = []
    for c, t in enumerate(temp.split("Dialogue")[1:]):
        if c == 0:
            vals.append(t.split(",")[-1].strip())
        else:
            vals.append(t.split(",")[-1].strip().lower())

    nTemp = temp.split("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text")[0]
    vtemp = temp.split("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text")[1]
    vStr = ''
    for v in vals:
        for x in vtemp.split(",")[:9]:
            vStr += x + ","
        vStr += v

    w = open("data/{}/subs.ass".format(count), "w")
    w.write(nTemp+"Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text"+vtemp)

# Start of Scripting---------
for tabe in table["data"]["children"]:
    if tabe["data"]["url"] in links: # Only do articles where the URL is provided
        print("Creating Video for: " + tabe["data"]["title"])
        titles.append(tabe["data"]["title"])
        texts.append(tabe["data"]["selftext"])
        
        


for count, text in enumerate(texts):
    if not os.path.exists("data/{}".format(count)):
        os.mkdir("data/{}".format(count))
    characters = int((4*300*(DURATION/60))) # Average Word Length is ~4.5
    data = {
    "text": text[:characters], # Word Count
    "model_id": "eleven_monolingual_v1",
    "voice_settings": {
        "stability": 0.5,
        "similarity_boost": 0.5
    }
    }

    if not os.path.exists("data/{}/tts.mp3".format(count)):
        print("Downloading New Recording")
        response = requests.post("https://api.elevenlabs.io/v1/text-to-speech/j9jfwdrw7BRfcR43Qohk", json=data, headers=headers)
        with open("data/{}/tts.mp3".format(count), 'wb') as f:
            for chunk in response.iter_content(chunk_size=CHUNK_SIZE):
                if chunk:
                    f.write(chunk)
    print("Voice Recordings: {} Finished".format(count))


# Print Texts
for count, text in enumerate(texts):
    print("Starting to Edit Videos #{}".format(count))
    # Download Pexel Videos
    if not os.path.exists("data/{}/video.mp4".format(count)):
        print("Video: {} Doesn't Exsists".format(count))

        r = requests.get("https://api.pexels.com/videos/search?query={}&per_page=10&orientation=portrait".format(video_types[random.randint(0, len(video_types)-1)]), headers={'Authorization': 'p1p0I9iC7ChShttx4Z29WDLsyfW6V6mSm05l0cE0evnxyYckEdCFqkEl'})


        ri = requests.get("https://api.pexels.com/videos/videos/{}".format(r.json()["videos"][random.randint(0, len(r.json()["videos"])-1)]["id"]), headers={'Authorization': 'p1p0I9iC7ChShttx4Z29WDLsyfW6V6mSm05l0cE0evnxyYckEdCFqkEl'})
        for i in ri.json()["video_files"]:
            if i["quality"] == "hd" and i["width"] == 1080:
                ro = requests.get(i["link"], headers={'Authorization': 'p1p0I9iC7ChShttx4Z29WDLsyfW6V6mSm05l0cE0evnxyYckEdCFqkEl'})
                # print(r.text)

                with open("data/{}/video.mp4".format(count),'wb') as f:
                  f.write(ro.content)

        print("Video: {} Finished Downloading".format(count))
    else:
        print("Video: {} Already Exsists".format(count))
    # Remove Audio and Crop Video
    if os.path.exists("data/{}/video.mp4".format(count)) and not os.path.exists("data/{}/video_soundless.mp4".format(count)):
        os.system('ffmpeg -i data/{}/video.mp4 -hide_banner -loglevel error -vf "scale=-1:1920, crop=1080:1920:656.25:0" -an data/{}/video_soundless.mp4'.format(count, count))
    else:
        print("Cropped Video: {} Already Exsists".format(count))

    # Loop 
    if os.path.exists("data/{}/video_soundless.mp4".format(count)) and not os.path.exists("data/{}/video_soundless_loop.mp4".format(count)):
        os.system("ffmpeg -stream_loop -1 -i data/{}/video_soundless.mp4 -hide_banner -loglevel error -t {}s -c copy data/{}/video_soundless_loop.mp4".format(count, DURATION, count))
    else:
        print("Looped and Soundless Video: {} Already Exsists".format(count))
    # Add TTS to Soundless Video
    if os.path.exists("data/{}/tts.mp3".format(count)) and os.path.exists("data/{}/video_soundless_loop.mp4".format(count)) and not os.path.exists("data/{}/video_tts_loop.mp4".format(count)):
        os.system("ffmpeg -i data/{}/video_soundless_loop.mp4 -i data/{}/tts.mp3 -hide_banner -loglevel error -t {}s -y data/{}/video_tts_loop.mp4".format(count, count , DURATION, count)) 
    else:
        print("TTS Video: {} Already Exsists".format(count))

    # Build SRT Subtitles
    if os.path.exists("data/{}/video_tts_loop.mp4".format(count)) and not os.path.exists("data/{}/subs.srt".format(count)):
        # vosk-transcriber -n vosk-model-en-us-0.22 -i data/0/video_tts_loop.mp4 -t srt -o data/0/subs.srt
        #os.system('vosk-transcriber -i data/{}/video_tts_loop.mp4 -t srt -o data/{}/subs.srt'.format(count, count))
        transcribe_audio(count) # Defined function, run whisper AI
    else:
        print("Subtitles: {} Already Exsists".format(count))

    # Translation of SRT Subtitles
    if os.path.exists("data/{}/tts.srt".format(count)) and not os.path.exists("data/{}/subs.ass".format(count)):
        os.system('ffmpeg -i data/{}/tts.srt  -hide_banner -loglevel error data/{}/subs.ass'.format(count, count))
    else:
        print("ASS Subtitles: {} Already Exsists".format(count))
    
    # Customize .ass Styles
    if os.path.exists("data/{}/subs.ass".format(count)):
        addCustomStyles(count) # Add Premade Header to generated files
    else:
        print("Something Has to Be Wrong in Custom ASS {}".format(count))

    # Add SRT Subtitles
    if os.path.exists("data/{}/subs.ass".format(count)) and os.path.exists("data/{}/video_tts_loop.mp4".format(count)) and not os.path.exists("build/output-{}.mp4".format(count)):
        os.system('ffmpeg -i data/{}/video_tts_loop.mp4 -hide_banner -loglevel error -vf ass=data/{}/subs.ass build/output-{}.mp4'.format(count, count, count))
    else:
        print("Finalized Video: {} Already Exsists".format(count))


print("-------\nPrint Titles: \t{}".format(titles))